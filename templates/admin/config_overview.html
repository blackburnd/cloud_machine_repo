{% extends "base.html" %}

{% block title %}Site Configuration{% endblock %}

{% block head %}
<link rel="stylesheet" href="/assets/style.css">
{% endblock %}

{% block content %}
<div class="config-overview">
    <div class="config-header">
        <h1>Site Configuration</h1>
        
        <div class="config-controls">
            <button onclick="sortByName()" class="sort-btn">Sort by Name</button>
            <button onclick="sortByValue()" class="sort-btn">Sort by Value</button>
        </div>
    </div>
    
    <div class="config-list" id="configList">
        {% for key, value in config.items() %}
        <div class="config-item">
            <div class="config-key">{{ key }}</div>
            {% if user_authenticated %}
            <div class="config-value editable-content" data-config-key="{{ key }}">
                {{ value }}
            </div>
            {% else %}
            <div class="config-value">{{ value }}</div>
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>

{% if user_authenticated %}
<script>
let originalContent = {};

// Add click event listeners to editable content
document.addEventListener('DOMContentLoaded', function() {
    const editableElements = document.querySelectorAll('.editable-content');
    
    // Add click-to-edit functionality to each editable element
    editableElements.forEach(element => {
        element.addEventListener('click', function(e) {
            // Don't start editing if already editing or if clicking on controls
            if (element.classList.contains('editing') || e.target.closest('.edit-controls')) {
                return;
            }
            startEdit(element);
        });
        
        // Add hover cursor styling
        element.style.cursor = 'pointer';
    });
});

function startEdit(element) {
    const configKey = element.getAttribute('data-config-key');
    
    // Get current text content directly from the element (excluding any existing controls)
    const clone = element.cloneNode(true);
    const existingControls = clone.querySelector('.edit-controls');
    if (existingControls) {
        existingControls.remove();
    }
    const currentText = clone.textContent.trim();
    
    // Store original content for canceling
    originalContent[configKey] = currentText;
    
    // Add editing class
    element.classList.add('editing');
    
    // Create editing interface
    const editingHTML = `
        <input type="text" class="content-input" value="${currentText}">
        <div class="edit-controls">
            <button class="edit-btn save-btn" onclick="saveContent(this)">Save</button>
            <button class="edit-btn cancel-btn" onclick="cancelEdit(this)">Cancel</button>
        </div>`;
    
    element.innerHTML = editingHTML;
    
    // Focus the input
    const input = element.querySelector('.content-input');
    if (input) {
        input.focus();
        input.select();
        
        // Add keyboard event listeners
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const saveBtn = element.querySelector('.save-btn');
                if (saveBtn) saveContent(saveBtn);
            } else if (e.key === 'Escape') {
                const cancelBtn = element.querySelector('.cancel-btn');
                if (cancelBtn) cancelEdit(cancelBtn);
            }
        });
    }
}

async function saveContent(button) {
    const element = button.closest('.editable-content');
    if (!element) {
        console.error('Could not find editable element for button:', button);
        return;
    }
    
    const input = element.querySelector('.content-input');
    if (!input) {
        console.error('Could not find input field');
        return;
    }
    
    const configKey = element.getAttribute('data-config-key');
    const newValue = input.value.trim();
    
    // Disable button during save
    button.textContent = 'Saving...';
    button.disabled = true;
    
    try {
        const response = await fetch('/admin/update-content', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                key: configKey,
                value: newValue
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Update the display content
            element.classList.remove('editing');
            element.innerHTML = newValue;
            
            // Show success feedback
            showFeedback('Content updated successfully!', 'success');
        } else {
            throw new Error(result.message);
        }
    } catch (error) {
        console.error('Save failed:', error);
        showFeedback('Failed to save: ' + error.message, 'error');
        
        // Restore original content on error
        cancelEdit(button.parentElement.querySelector('.cancel-btn'));
    } finally {
        button.textContent = 'Save';
        button.disabled = false;
    }
}

function cancelEdit(button) {
    const element = button.closest('.editable-content');
    if (!element) {
        console.error('Could not find editable element for button:', button);
        return;
    }
    
    const configKey = element.getAttribute('data-config-key');
    const originalText = originalContent[configKey];
    
    // Remove editing class
    element.classList.remove('editing');
    
    // Restore original content
    element.innerHTML = originalText;
}

function showFeedback(message, type) {
    // Create feedback element
    const feedback = document.createElement('div');
    feedback.className = `feedback-message ${type}`;
    feedback.textContent = message;
    
    document.body.appendChild(feedback);
    
    // Animate in
    setTimeout(() => {
        feedback.classList.add('show');
    }, 100);
    
    // Remove after 3 seconds
    setTimeout(() => {
        feedback.classList.remove('show');
        setTimeout(() => {
            if (document.body.contains(feedback)) {
                document.body.removeChild(feedback);
            }
        }, 300);
    }, 3000);
}

function sortByName() {
    const configList = document.getElementById('configList');
    const items = Array.from(configList.getElementsByClassName('config-item'));
    
    items.sort((a, b) => {
        const keyA = a.querySelector('.config-key').textContent.toLowerCase();
        const keyB = b.querySelector('.config-key').textContent.toLowerCase();
        return keyA.localeCompare(keyB);
    });
    
    // Re-append sorted items
    items.forEach(item => configList.appendChild(item));
}

function sortByValue() {
    const configList = document.getElementById('configList');
    const items = Array.from(configList.getElementsByClassName('config-item'));
    
    items.sort((a, b) => {
        const valueA = a.querySelector('.config-value').textContent.toLowerCase();
        const valueB = b.querySelector('.config-value').textContent.toLowerCase();
        return valueA.localeCompare(valueB);
    });
    
    // Re-append sorted items
    items.forEach(item => configList.appendChild(item));
}
</script>
{% endif %}
{% endblock %}
