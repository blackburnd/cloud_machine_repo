"""
Schema Dump Module - PostgreSQL schema extraction without pg_dump
Avoids version compatibility issues by using direct database queries
"""

import os
from datetime import datetime
from databases import Database
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)


class SchemaDumper:
    """Database schema dumper that extracts schema using SQL queries"""
    
    def __init__(self, database_url: str = None):
        """Initialize with database URL"""
        self.database_url = database_url or os.getenv("_DATABASE_URL") or os.getenv("DATABASE_URL")
        if not self.database_url:
            raise ValueError("Database URL not provided and not found in environment variables")
    
    async def generate_schema_sql(self) -> str:
        """Generate complete schema SQL dump"""
        db = Database(self.database_url)
        await db.connect()
        
        try:
            schema_lines = []
            schema_lines.append("-- Database Schema Export")
            schema_lines.append(f"-- Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            schema_lines.append("-- PostgreSQL Database Schema")
            schema_lines.append("-- Generated by Python schema dumper")
            schema_lines.append("")
            
            # Add sequences first (needed for tables with serial columns)
            sequences = await self._get_sequences(db)
            if sequences:
                schema_lines.extend(sequences)
                schema_lines.append("")
            
            # Add tables
            tables = await self._get_tables(db)
            schema_lines.extend(tables)
            
            # Add indexes (non-primary key indexes)
            indexes = await self._get_indexes(db)
            if indexes:
                schema_lines.append("-- Indexes")
                schema_lines.extend(indexes)
                schema_lines.append("")
            
            # Add foreign key constraints
            foreign_keys = await self._get_foreign_keys(db)
            if foreign_keys:
                schema_lines.append("-- Foreign Key Constraints")
                schema_lines.extend(foreign_keys)
                schema_lines.append("")
            
            return "\n".join(schema_lines)
            
        finally:
            await db.disconnect()
    
    async def _get_tables(self, db: Database) -> List[str]:
        """Get CREATE TABLE statements for all tables"""
        lines = []
        
        # Get all tables
        tables_query = """
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_type = 'BASE TABLE'
            ORDER BY table_name;
        """
        tables = await db.fetch_all(tables_query)
        
        for table in tables:
            table_name = table['table_name']
            lines.append(f"-- Table: {table_name}")
            
            # Get table structure
            columns_query = """
                SELECT 
                    column_name,
                    data_type,
                    character_maximum_length,
                    numeric_precision,
                    numeric_scale,
                    column_default,
                    is_nullable,
                    ordinal_position
                FROM information_schema.columns 
                WHERE table_schema = 'public' 
                AND table_name = :table_name
                ORDER BY ordinal_position;
            """
            columns = await db.fetch_all(columns_query, {"table_name": table_name})
            
            # Build CREATE TABLE statement
            create_table = f"CREATE TABLE {table_name} ("
            column_defs = []
            
            for col in columns:
                col_def = self._format_column_definition(col)
                column_defs.append(f"    {col_def}")
            
            # Get primary key constraint
            pk_constraint = await self._get_primary_key(db, table_name)
            if pk_constraint:
                column_defs.append(f"    {pk_constraint}")
            
            create_table += "\n" + ",\n".join(column_defs) + "\n);"
            lines.append(create_table)
            lines.append("")
        
        return lines
    
    def _format_column_definition(self, col: Dict[str, Any]) -> str:
        """Format a single column definition"""
        col_name = col['column_name']
        col_type = col['data_type']
        
        # Handle type specifications
        if col_type == 'character varying' and col['character_maximum_length']:
            col_type = f"varchar({col['character_maximum_length']})"
        elif col_type == 'character' and col['character_maximum_length']:
            col_type = f"char({col['character_maximum_length']})"
        elif col_type == 'numeric' and col['numeric_precision']:
            if col['numeric_scale']:
                col_type = f"numeric({col['numeric_precision']},{col['numeric_scale']})"
            else:
                col_type = f"numeric({col['numeric_precision']})"
        elif col_type == 'timestamp without time zone':
            col_type = 'timestamp'
        elif col_type == 'timestamp with time zone':
            col_type = 'timestamptz'
        
        # Handle nullability
        nullable = "" if col['is_nullable'] == 'YES' else " NOT NULL"
        
        # Handle defaults
        default = ""
        if col['column_default']:
            default_val = col['column_default']
            # Clean up some common default formats
            if default_val.startswith("nextval("):
                # This is a sequence default, keep as-is
                default = f" DEFAULT {default_val}"
            elif default_val == "CURRENT_TIMESTAMP" or default_val == "now()":
                default = f" DEFAULT {default_val}"
            elif default_val.startswith("'") and default_val.endswith("'::"):
                # String literal with type cast
                default = f" DEFAULT {default_val}"
            else:
                default = f" DEFAULT {default_val}"
        
        return f"{col_name} {col_type}{nullable}{default}"
    
    async def _get_primary_key(self, db: Database, table_name: str) -> str:
        """Get primary key constraint for a table"""
        pk_query = """
            SELECT 
                tc.constraint_name,
                string_agg(kcu.column_name, ', ' ORDER BY kcu.ordinal_position) as columns
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu 
                ON tc.constraint_name = kcu.constraint_name
                AND tc.table_schema = kcu.table_schema
            WHERE tc.constraint_type = 'PRIMARY KEY'
                AND tc.table_schema = 'public'
                AND tc.table_name = :table_name
            GROUP BY tc.constraint_name;
        """
        
        result = await db.fetch_one(pk_query, {"table_name": table_name})
        if result:
            return f"CONSTRAINT {result['constraint_name']} PRIMARY KEY ({result['columns']})"
        return ""
    
    async def _get_sequences(self, db: Database) -> List[str]:
        """Get CREATE SEQUENCE statements"""
        lines = []
        
        sequences_query = """
            SELECT sequence_name
            FROM information_schema.sequences
            WHERE sequence_schema = 'public'
            ORDER BY sequence_name;
        """
        sequences = await db.fetch_all(sequences_query)
        
        if sequences:
            lines.append("-- Sequences")
            
            for seq in sequences:
                seq_name = seq['sequence_name']
                
                # Get sequence details
                seq_details_query = f"""
                    SELECT last_value, start_value, increment_by, max_value, min_value, cache_value, is_cycled
                    FROM {seq_name};
                """
                try:
                    seq_details = await db.fetch_one(seq_details_query)
                    
                    create_seq = f"""CREATE SEQUENCE {seq_name}
    START WITH {seq_details['start_value']}
    INCREMENT BY {seq_details['increment_by']}
    MINVALUE {seq_details['min_value']}
    MAXVALUE {seq_details['max_value']}
    CACHE {seq_details['cache_value']}"""
                    
                    if seq_details['is_cycled']:
                        create_seq += "\n    CYCLE"
                    
                    create_seq += ";"
                    lines.append(create_seq)
                    lines.append("")
                    
                except Exception as e:
                    logger.warning(f"Could not read sequence {seq_name}: {e}")
                    lines.append(f"-- CREATE SEQUENCE {seq_name};")
                    lines.append("")
        
        return lines
    
    async def _get_indexes(self, db: Database) -> List[str]:
        """Get CREATE INDEX statements (excluding primary key indexes)"""
        lines = []
        
        indexes_query = """
            SELECT 
                schemaname,
                tablename,
                indexname,
                indexdef
            FROM pg_indexes 
            WHERE schemaname = 'public' 
            AND indexname NOT LIKE '%_pkey'
            ORDER BY tablename, indexname;
        """
        indexes = await db.fetch_all(indexes_query)
        
        for index in indexes:
            lines.append(f"{index['indexdef']};")
        
        return lines
    
    async def _get_foreign_keys(self, db: Database) -> List[str]:
        """Get foreign key constraints"""
        lines = []
        
        fk_query = """
            SELECT
                tc.table_name,
                tc.constraint_name,
                kcu.column_name,
                ccu.table_name AS foreign_table_name,
                ccu.column_name AS foreign_column_name,
                rc.update_rule,
                rc.delete_rule
            FROM information_schema.table_constraints AS tc
            JOIN information_schema.key_column_usage AS kcu
                ON tc.constraint_name = kcu.constraint_name
                AND tc.table_schema = kcu.table_schema
            JOIN information_schema.constraint_column_usage AS ccu
                ON ccu.constraint_name = tc.constraint_name
                AND ccu.table_schema = tc.table_schema
            JOIN information_schema.referential_constraints AS rc
                ON tc.constraint_name = rc.constraint_name
                AND tc.table_schema = rc.constraint_schema
            WHERE tc.constraint_type = 'FOREIGN KEY'
                AND tc.table_schema = 'public'
            ORDER BY tc.table_name, tc.constraint_name;
        """
        
        foreign_keys = await db.fetch_all(fk_query)
        
        for fk in foreign_keys:
            alter_statement = f"""ALTER TABLE {fk['table_name']} 
    ADD CONSTRAINT {fk['constraint_name']} 
    FOREIGN KEY ({fk['column_name']}) 
    REFERENCES {fk['foreign_table_name']}({fk['foreign_column_name']})"""
            
            if fk['update_rule'] != 'NO ACTION':
                alter_statement += f" ON UPDATE {fk['update_rule']}"
            if fk['delete_rule'] != 'NO ACTION':
                alter_statement += f" ON DELETE {fk['delete_rule']}"
            
            alter_statement += ";"
            lines.append(alter_statement)
        
        return lines


async def generate_schema_dump(database_url: str = None) -> str:
    """Convenience function to generate schema dump"""
    dumper = SchemaDumper(database_url)
    return await dumper.generate_schema_sql()


# For backwards compatibility and testing
if __name__ == "__main__":
    import asyncio
    
    async def main():
        try:
            schema = await generate_schema_dump()
            print(schema)
        except Exception as e:
            print(f"Error: {e}")
    
    asyncio.run(main())
